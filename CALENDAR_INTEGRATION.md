# Google Calendar Integration - Implementation Guide

This document describes the complete Google Calendar integration for the kanari burnout detection app.

## Overview

The calendar integration allows users to:
- Connect their Google Calendar via OAuth 2.0
- Schedule recovery blocks automatically based on voice analysis
- Find optimal time slots using free/busy information
- Receive calendar reminders for recovery activities

## Architecture

### File Structure

```
lib/calendar/
â”œâ”€â”€ oauth.ts          # OAuth 2.0 utilities (PKCE flow, token management)
â”œâ”€â”€ api.ts            # Google Calendar API wrapper
â””â”€â”€ scheduler.ts      # Recovery block scheduling logic

app/api/auth/google/
â”œâ”€â”€ route.ts          # OAuth initiation endpoint
â””â”€â”€ callback/route.ts # OAuth callback handler

hooks/
â””â”€â”€ use-calendar.ts   # React hook for calendar operations

components/dashboard/
â”œâ”€â”€ settings-content.tsx   # Connect/disconnect UI
â””â”€â”€ suggestions/page.tsx   # Schedule to calendar buttons
```

## Implementation Details

### 1. OAuth 2.0 Flow (lib/calendar/oauth.ts)

**Security Features:**
- PKCE (Proof Key for Code Exchange) for enhanced security
- CSRF protection via state parameter
- Automatic token refresh when expired
- Secure token storage in localStorage

**Key Functions:**
- `generateAuthUrl()` - Creates authorization URL with PKCE
- `exchangeCodeForTokens()` - Exchanges auth code for tokens
- `refreshAccessToken()` - Refreshes expired tokens
- `revokeToken()` - Disconnects calendar (logout)

**Token Storage:**
Tokens are stored in localStorage under the key `kanari_calendar_tokens`.

**Note:** For production, implement encryption using Web Crypto API (AES-GCM).

### 2. Calendar API Wrapper (lib/calendar/api.ts)

Direct REST API calls to Google Calendar API v3.

**Core Operations:**
- `createCalendarEvent()` - Create recovery events
- `updateCalendarEvent()` - Update existing events
- `deleteCalendarEvent()` - Remove events
- `getFreeBusy()` - Query available time slots

**Helper Functions:**
- `suggestionToEventParams()` - Converts Suggestion â†’ CalendarEvent
- `findNextAvailableSlot()` - Finds next free time slot
- `hasConflict()` - Checks for scheduling conflicts

**Event Format:**
```typescript
{
  summary: "ðŸƒ Recovery: exercise",
  description: "[Suggestion content]\n\nðŸ’¡ Rationale: [rationale]\n\nðŸ¤– Generated by kanari",
  start: { dateTime: "2025-01-15T14:00:00Z", timeZone: "America/Los_Angeles" },
  end: { dateTime: "2025-01-15T14:15:00Z", timeZone: "America/Los_Angeles" },
  colorId: "9", // Blue
  reminders: {
    overrides: [
      { method: "popup", minutes: 10 },
      { method: "popup", minutes: 30 }
    ]
  }
}
```

### 3. Scheduler (lib/calendar/scheduler.ts)

**Smart Scheduling:**
- Respects user's preferred recovery times
- Checks calendar availability via free/busy
- Falls back to next available slot if preferred times are busy
- Only schedules during working hours (8 AM - 8 PM)
- Rounds to 15-minute intervals

**Key Functions:**
- `scheduleRecoveryBlock()` - Main scheduling function
- `findOptimalTimeSlot()` - Finds best time based on preferences
- `scheduleMultipleRecoveryBlocks()` - Batch scheduling

**Preferred Times Logic:**
1. Check user's `preferredRecoveryTimes` (e.g., ["14:00", "16:00"])
2. Try each preferred time for today and tomorrow
3. If all busy, use `findNextAvailableSlot()` (checks every 15 min)
4. Search window: 24 hours from now

### 4. API Routes

#### OAuth Initiation (app/api/auth/google/route.ts)
```
GET /api/auth/google
â†’ Returns { authUrl: "https://accounts.google.com/..." }
â†’ Client redirects to authUrl
```

#### OAuth Callback (app/api/auth/google/callback/route.ts)
```
GET /api/auth/google/callback?code=...&state=...
â†’ Exchanges code for tokens
â†’ Redirects to /dashboard/settings#tokens={...}
â†’ Client stores tokens in localStorage
```

**Error Handling:**
- Missing parameters â†’ redirect with error message
- Token exchange failure â†’ redirect with error
- CSRF validation â†’ state parameter verification

### 5. React Hook (hooks/use-calendar.ts)

**State Management:**
```typescript
const {
  isConnected,      // boolean - calendar connected?
  isLoading,        // boolean - operation in progress?
  error,            // string | null - error message
  connect,          // () => Promise<void> - initiate OAuth
  disconnect,       // () => Promise<void> - revoke tokens
  scheduleEvent,    // (Suggestion, UserSettings) => Promise<RecoveryBlock>
  deleteEvent,      // (eventId) => Promise<void>
  clearError,       // () => void - dismiss error
  refreshTokens,    // () => Promise<boolean> - manually refresh
} = useCalendar()
```

**Auto Token Refresh:**
Hook automatically refreshes tokens if they're expired or will expire within 5 minutes.

**OAuth Callback Handling:**
Listens for URL hash containing tokens from callback redirect:
```
/dashboard/settings#tokens={"access_token":"...","refresh_token":"..."}
```

### 6. UI Components

#### Settings Page (components/dashboard/settings-content.tsx)

**Features:**
- Connect/Disconnect button
- Connection status indicator (green dot when connected)
- Success/error messages
- Auto-schedule toggle (disabled until connected)
- Informational help text

**States:**
- Not connected: Shows "Connect" button
- Connected: Shows "Disconnect" button + green indicator
- Loading: Shows "Connecting..." / "Disconnecting..."
- Error: Shows error banner with dismiss button
- Success: Shows success banner (auto-dismiss after 5s)

#### Suggestions Page (app/dashboard/suggestions/page.tsx)

**Suggestion Cards:**
Each card shows:
- Category icon and badge
- Duration indicator
- Suggestion content and rationale
- Action buttons

**Schedule Button States:**
1. Not connected: Disabled with hint "Connect calendar to schedule"
2. Scheduling: Shows spinner "Scheduling..."
3. Scheduled: Shows green checkmark "Scheduled" (disabled)

**Mock Data:**
Page includes 3 mock suggestions for demonstration. In production, these will come from Gemini API.

## Environment Setup

### Required Environment Variables

Create `.env.local`:
```bash
# Server-side (API routes)
GOOGLE_CLIENT_ID=your_client_id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your_client_secret
GOOGLE_REDIRECT_URI=http://localhost:3000/api/auth/google/callback

# Client-side (browser)
NEXT_PUBLIC_GOOGLE_CLIENT_ID=your_client_id.apps.googleusercontent.com
NEXT_PUBLIC_GOOGLE_CLIENT_SECRET=your_client_secret
NEXT_PUBLIC_GOOGLE_REDIRECT_URI=http://localhost:3000/api/auth/google/callback
```

### Google Cloud Console Setup

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a new project or select existing
3. Enable **Google Calendar API**
4. Go to **Credentials** â†’ **Create Credentials** â†’ **OAuth 2.0 Client ID**
5. Configure OAuth consent screen:
   - User Type: External
   - App name: "kanari"
   - Scopes: `calendar.events`, `calendar.readonly`
6. Add authorized redirect URIs:
   - Development: `http://localhost:3000/api/auth/google/callback`
   - Production: `https://yourdomain.com/api/auth/google/callback`
7. Copy Client ID and Client Secret to `.env.local`

### Scopes Requested

```
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.readonly
```

## Usage Flow

### User Journey

1. **Connect Calendar**
   - User goes to Settings â†’ Calendar Integration
   - Clicks "Connect" button
   - Redirected to Google consent screen
   - Grants access to calendar
   - Redirected back to Settings
   - Success message shown, green dot appears

2. **Schedule Recovery Block**
   - User goes to Suggestions page
   - Sees AI-generated recovery suggestions
   - Clicks "Schedule" on a suggestion
   - System finds optimal time slot
   - Event created in Google Calendar
   - Button changes to "Scheduled" with checkmark

3. **Auto-Schedule (Future)**
   - User enables "Auto-Schedule Recovery" in Settings
   - When elevated stress detected from voice analysis
   - System automatically schedules recovery blocks
   - User receives calendar notifications

## Data Flow

```
Voice Recording
  â†“
Audio Features Extraction
  â†“
TensorFlow.js Stress/Fatigue Classification
  â†“
Send scores to Gemini 3 API
  â†“
Receive Suggestions
  â†“
User clicks "Schedule"
  â†“
useCalendar.scheduleEvent()
  â†“
scheduler.scheduleRecoveryBlock()
  â”œâ”€ getFreeBusy() â†’ Check calendar availability
  â”œâ”€ findOptimalTimeSlot() â†’ Find best time
  â””â”€ createCalendarEvent() â†’ Create event
  â†“
Recovery block created in Google Calendar
  â†“
Update suggestion status to "scheduled"
```

## Security Considerations

### Current Implementation (Prototype)
- Tokens stored in localStorage (unencrypted)
- State parameter for CSRF protection
- PKCE for OAuth flow security
- Token auto-refresh on expiration

### Production Recommendations
1. **Encrypt tokens** using Web Crypto API (AES-GCM)
2. **Use HTTP-only cookies** instead of localStorage
3. **Implement session management** with secure backend
4. **Add rate limiting** on API routes
5. **Validate all user inputs**
6. **Use environment-specific redirect URIs**
7. **Implement proper error logging** (not console.error)
8. **Add token expiration monitoring**

## Testing

### Manual Testing Checklist

- [ ] OAuth flow initiates correctly
- [ ] Google consent screen appears
- [ ] Callback handles tokens properly
- [ ] Tokens stored in localStorage
- [ ] Connect/disconnect works
- [ ] Schedule button creates event
- [ ] Event appears in Google Calendar
- [ ] Event has correct time, title, description
- [ ] Reminders are set
- [ ] Token refresh works when expired
- [ ] Error messages display correctly
- [ ] Success messages auto-dismiss

### Test Scenarios

1. **First-time connection**
   - No refresh token
   - Consent screen shown
   - Tokens stored

2. **Token expiration**
   - Auto-refresh triggered
   - New access token obtained
   - Old refresh token preserved

3. **Scheduling conflicts**
   - Busy period detected
   - Next available slot found
   - Event created successfully

4. **Preferred times**
   - User sets preferred recovery times
   - System tries preferred times first
   - Falls back to next available if busy

## Future Enhancements

1. **Calendar Selection**
   - Let user choose which calendar to use
   - Support multiple calendars

2. **Time Zone Handling**
   - Better time zone awareness
   - Handle DST transitions

3. **Recurring Events**
   - Schedule recurring recovery blocks
   - Daily/weekly patterns

4. **Smart Rescheduling**
   - Detect calendar changes
   - Offer to reschedule if conflict

5. **Analytics**
   - Track recovery block completion
   - Measure effectiveness

6. **Batch Operations**
   - Schedule multiple suggestions at once
   - Weekly recovery planning

## Troubleshooting

### "OAuth configuration missing"
- Check `.env.local` exists
- Verify all environment variables are set
- Restart dev server after changes

### "Token exchange failed"
- Check Client ID and Secret are correct
- Verify redirect URI matches exactly
- Check Google Cloud Console credentials

### "Failed to schedule event"
- Verify calendar is connected
- Check token hasn't expired
- Ensure Calendar API is enabled
- Check network requests in DevTools

### "No available time slots found"
- User's calendar is fully booked
- Increase search window (default 24 hours)
- Adjust working hours range (default 8 AM - 8 PM)

## Dependencies

- **Next.js 16** - App framework
- **React 19** - UI library
- **TypeScript** - Type safety
- **googleapis** (optional) - Calendar API client library

Note: Current implementation uses direct fetch to Calendar API REST endpoints, so `googleapis` is not strictly required but included for potential future use.

## API Reference

### Calendar API Endpoints Used

```
POST /calendar/v3/calendars/{calendarId}/events
PATCH /calendar/v3/calendars/{calendarId}/events/{eventId}
DELETE /calendar/v3/calendars/{calendarId}/events/{eventId}
GET /calendar/v3/calendars/{calendarId}/events/{eventId}
POST /calendar/v3/freeBusy
```

### OAuth Endpoints

```
GET https://accounts.google.com/o/oauth2/v2/auth
POST https://oauth2.googleapis.com/token
POST https://oauth2.googleapis.com/revoke
```

## License

MIT - Part of the kanari project for Google DeepMind Gemini 3 Hackathon 2025.
